Mentorship Web Application Specifications

General Description

App Name: Mentorship
Purpose: Manage a mentorship program for a startup incubator scenario.

Roles:
	‚Ä¢	Mentor
	‚Ä¢	Startup Founder
	‚Ä¢	Startup Employee

The application connects Mentors with Startup Founders and their Employees, facilitating mentorship session requests, scheduling, and record-keeping of session histories. The goal is to provide a clear, role-based interface where founders can manage their startup teams, employees can request mentorship sessions, and mentors can review and respond to those requests.

Functional Requirements

Common User Capabilities

	‚Ä¢	User Profiles:
	‚Ä¢	All users (Mentors, Founders, Employees) have profiles with fields: name, email, avatar_url (optional), bio (for mentors/employees), and any role-specific attributes (e.g., mentors‚Äô calendar link).
	‚Ä¢	Users can update their profiles at any time (bio, avatar, etc.).
	‚Ä¢	Authentication & Authorization:
	‚Ä¢	Use üçã Clerk for secure user authentication and session management.
	‚Ä¢	Store user roles (Mentor, Founder, Employee) in the database and associate them with Clerk user IDs for RBAC enforcement.
	‚Ä¢	Founders can invite new Employees by email, triggering a Clerk invite flow.

Mentor Role

Mentors can:
	‚Ä¢	Add a calendar link (e.g., Calendly) to their profile to indicate availability.
	‚Ä¢	Add a detailed bio describing their expertise.
	‚Ä¢	View incoming mentorship session requests from Startup Founders/Employees.
	‚Ä¢	Accept or reject session requests.
	‚Ä¢	View scheduled (upcoming) sessions.
	‚Ä¢	View past sessions with notes or outcomes.

Startup Employee Role

Startup Employees can:
	‚Ä¢	Add a bio to their profile.
	‚Ä¢	Browse a list of mentors, view mentor details (expertise, bio, calendar link).
	‚Ä¢	Request mentorship sessions by providing date/time preferences and a brief session agenda.
	‚Ä¢	View upcoming (planned) sessions.
	‚Ä¢	View past sessions and session notes.

Startup Founder Role

Startup Founders have all the Employee capabilities plus:
	‚Ä¢	Invite new Startup Employees via email.
	‚Ä¢	Manage their startup‚Äôs profile data: startup_name, logo_url, industry, description, and any key metrics.
	‚Ä¢	Potentially access aggregated session history or metrics relevant to their startup.

Session Lifecycle and Additional Details

	‚Ä¢	Session Requests:
	‚Ä¢	Employees or Founders request sessions with Mentors by specifying preferred times, topics, and optional notes.
	‚Ä¢	Mentors can accept, reject, or propose a different time (if supported).
	‚Ä¢	Notifications:
	‚Ä¢	Trigger notifications and emails when:
	1.	A session is requested by an Employee or Founder.
	2.	A session is accepted by a Mentor.
	3.	A session is rejected by a Mentor.
	‚Ä¢	Notifications appear in a dedicated notification center within the app and are also sent via email.
	‚Ä¢	Users can view a list of notifications, each indicating the event type and related session details.
	‚Ä¢	Cancellations and Rescheduling (optional enhancement):
	‚Ä¢	If desired, specify whether sessions can be canceled or rescheduled and who has the authority to do so (Mentor, Employee/Founder, or both).
	‚Ä¢	Such actions would also trigger notifications and emails.
	‚Ä¢	Search and Filtering:
	‚Ä¢	Employees can filter mentors by expertise, availability, or rating (if implemented).
	‚Ä¢	Users can filter upcoming or past sessions by date or mentor name.

Technical Requirements

Stack Overview:
	‚Ä¢	Framework: Next.js (App Router)
	‚Ä¢	Language: TypeScript
	‚Ä¢	UI/Styling: Shadcn UI, Radix UI, Tailwind CSS
	‚Ä¢	Database and ORM: Neon (PostgreSQL) + Drizzle ORM
	‚Ä¢	Authentication: Clerk
	‚Ä¢	State Management: Nuqs
	‚Ä¢	Email and Notifications: Resend + React Email

Code Style and Structure

	‚Ä¢	Use functional, declarative patterns; avoid classes.
	‚Ä¢	Descriptive variable names (isLoading, hasError, etc.).
	‚Ä¢	Code organization:
	‚Ä¢	app/components/ for shared UI components
	‚Ä¢	db/schema/ for Drizzle schemas
	‚Ä¢	lib/ for utilities and helper functions
	‚Ä¢	Keep domain-specific logic in appropriate directories
	‚Ä¢	Use named exports for components.
	‚Ä¢	Use TypeScript interfaces for data models; avoid enum in favor of union types or object maps.
	‚Ä¢	Format with Prettier, lint with ESLint.

TypeScript and Drizzle Integration

	‚Ä¢	Define all schemas using Drizzle in db/schema.
	‚Ä¢	Represent Users, Roles, Startups, Sessions, and Notifications as TypeScript interfaces aligned with Drizzle‚Äôs schema definitions.
	‚Ä¢	Maintain schema migrations using Drizzle CLI, running them in CI/CD before deployment.
	‚Ä¢	Ensure schema evolution is tracked and tested.

Database (Neon) and Data Flow

	‚Ä¢	Neon PostgreSQL stores all persistent data (users, sessions, startups, notifications).
	‚Ä¢	Fetch data in Next.js Server Components via Drizzle queries for minimal client-side complexity.
	‚Ä¢	Use Next.js server actions for create/update/delete operations (e.g., requesting a session, accepting a session).

Authentication with Clerk

	‚Ä¢	Integrate Clerk to handle sign-up, sign-in, password resets, and session tokens.
	‚Ä¢	Associate each Clerk user ID with a role and startup ID (if applicable) in the Neon database.
	‚Ä¢	Ensure protected routes are only accessible to users with appropriate roles.

State Management with Nuqs

	‚Ä¢	Use üçì Nuqs for minimal client-side state such as UI toggles or local filters.
	‚Ä¢	Most data is server-fetched, so global state is minimized.
	‚Ä¢	Nuqs stores might handle things like the currently selected mentor in the mentors list UI or temporary filter criteria.

UI and Styling

	‚Ä¢	Responsive design with Tailwind CSS.
	‚Ä¢	Use Shadcn UI and Radix UI to build an accessible, consistent component library.
	‚Ä¢	Define a design system (colors, typography, spacing) in Tailwind config.
	‚Ä¢	Implement a notification center UI to list recent notifications.

Notifications and Email Management

	‚Ä¢	Notifications:
	‚Ä¢	Display notifications in a dedicated in-app notification center.
	‚Ä¢	Notifications are triggered by specific events (session requested, accepted, rejected).
	‚Ä¢	Store notifications in the database with references to related users and sessions.
	‚Ä¢	Email:
	‚Ä¢	Use üçá Resend and üçâ React Email to send email notifications.
	‚Ä¢	On triggering events, send a well-structured HTML email built with React Email components.
	‚Ä¢	Email content includes session details, user info, and a link to view the session in the app.
	‚Ä¢	Ensure emails are responsive and accessible.

Performance Optimization

	‚Ä¢	Minimize use client directives; rely on server components for data fetching.
	‚Ä¢	Use <Suspense> and dynamic imports to load non-critical components lazily.
	‚Ä¢	Optimize images (Next.js Image, WebP format), specify dimensions to avoid layout shifts.
	‚Ä¢	Monitor and improve Core Web Vitals (LCP, CLS, FID).

Security and Error Handling

	‚Ä¢	Use Clerk for secure authentication and ensure all sensitive routes require proper login.
	‚Ä¢	Enforce RBAC at the server action level (e.g., only mentors can accept/reject sessions).
	‚Ä¢	Validate input data (e.g., bios, session requests) on the server.
	‚Ä¢	Handle errors gracefully with structured JSON error responses, UI fallback states, and toast notifications for form errors.

Startup and Invite Management

	‚Ä¢	Founders invite Employees by email via Clerk‚Äôs invitation flow.
	‚Ä¢	Employees join their startup upon accepting the invite link.
	‚Ä¢	Startup profiles (logo, description, etc.) managed by the Founder.
	‚Ä¢	Data is stored in Neon and fetched via Drizzle.

Testing, CI/CD, and Documentation

	‚Ä¢	Testing:
	‚Ä¢	Jest for unit tests
	‚Ä¢	React Testing Library for component tests
	‚Ä¢	Playwright or Cypress for end-to-end tests
	‚Ä¢	CI/CD:
	‚Ä¢	Run linting, type checks, and Drizzle migrations in CI.
	‚Ä¢	Run automated tests before production deployment.
	‚Ä¢	Documentation:
	‚Ä¢	README for onboarding (setup, environment variables, running local development).
	‚Ä¢	Architectural diagrams (ERD for database, component hierarchy).
	‚Ä¢	Endpoint and server action documentation (potentially OpenAPI/Swagger).